'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var O = Object;

/*  ------------------------------------------------------------------------ */

var merge = function merge(to, from) {

    for (var prop in from) {
        O.defineProperty(to, prop, O.getOwnPropertyDescriptor(from, prop));
    }

    return to;
};

/*  ------------------------------------------------------------------------ */

var pipez = module.exports = function (functions_, prev) {

    var functions = {}; // bound to self

    var functionNames = Reflect.ownKeys(functions_); // guaranteed to be in property creation order (as defined by the standard)
    var self = O.assign(

    /*  Function of functions (call chain)  */

    function () {
        for (var _len = arguments.length, initial = Array(_len), _key = 0; _key < _len; _key++) {
            initial[_key] = arguments[_key];
        }

        return functionNames.reduce(function (memo, k) {
            return functions[k].call(self, memo, { initialArguments: initial });
        }, initial);
    },

    /*  Additional methods     */

    {
        configure: function configure() {
            var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};


            var modifiedFunctions = {};

            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                var _loop = function _loop() {
                    var k = _step.value;


                    var override = overrides[k],
                        before = overrides['+' + k] || function (x) {
                        return x;
                    },
                        after = overrides[k + '+'] || function (x) {
                        return x;
                    };

                    var boundArgs = typeof override === 'boolean' ? { yes: override } : override || {};

                    modifiedFunctions[k] = function (x, args) {

                        var fn = typeof override === 'function' ? override : functions[k]; // dont cache so people can dynamically change .impl ()

                        var newArgs = O.assign({}, boundArgs, args),
                            maybeFn = newArgs.yes === false ? function (x) {
                            return x;
                        } : fn;

                        return after.call(this, maybeFn.call(this, before.call(this, x, newArgs), newArgs), newArgs);
                    };
                };

                for (var _iterator = functionNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    _loop();
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            return pipez(modifiedFunctions, self).methods(this.methods_);
        },
        from: function from(name) {

            var subset = null;

            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = functionNames[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var _k = _step2.value;

                    if (_k === name) {
                        subset = { takeFirstArgument: function takeFirstArgument(args, cfg) {
                                return args[0];
                            } };
                    }
                    if (subset) {
                        subset[_k] = functions[_k];
                    }
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            return pipez(subset, self);
        },
        before: function before(name) {

            var subset = {};

            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = functionNames[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var _k2 = _step3.value;

                    if (_k2 === name) break;
                    subset[_k2] = functions[_k2];
                }
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }

            return pipez(subset, self);
        },


        methods_: {},

        methods: function methods(_methods) {
            return merge(this, merge(this.methods_, _methods));
        },


        get impl() {
            return functions;
        },
        get prev() {
            return prev;
        }
    });

    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
        for (var _iterator4 = O.entries(functions_)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var _step4$value = _slicedToArray(_step4.value, 2),
                _k3 = _step4$value[0],
                f = _step4$value[1];

            functions[_k3] = f.bind(self);
        }
    } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
                _iterator4.return();
            }
        } finally {
            if (_didIteratorError4) {
                throw _iteratorError4;
            }
        }
    }

    return self;
};

/*  ------------------------------------------------------------------------ */

//# sourceMappingURL=data:application/json;base64,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QUFiOztBQUxpRDtBQUFBO0FBQUE7O0FBQUE7QUEyRWpELDhCQUFtQixFQUFFLE9BQUYsQ0FBVyxVQUFYLENBQW5CLG1JQUEyQztBQUFBO0FBQUEsZ0JBQWpDLEdBQWlDO0FBQUEsZ0JBQTlCLENBQThCOztBQUFFLHNCQUFVLEdBQVYsSUFBZSxFQUFFLElBQUYsQ0FBUSxJQUFSLENBQWY7QUFBOEI7QUEzRTFCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBNkVqRCxXQUFPLElBQVA7QUFDSCxDQTlFRDs7QUFnRkEiLCJmaWxlIjoicGlwZXouZXM1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgTyA9IE9iamVjdFxuXG4vKiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbmNvbnN0IG1lcmdlID0gKHRvLCBmcm9tKSA9PiB7XG5cbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gZnJvbSkgeyBPLmRlZmluZVByb3BlcnR5ICh0bywgcHJvcCwgTy5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgKGZyb20sIHByb3ApKSB9XG5cbiAgICByZXR1cm4gdG9cbn1cblxuLyogIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5jb25zdCBwaXBleiA9IG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uc18sIHByZXYpID0+IHtcblxuICAgIGxldCBmdW5jdGlvbnMgPSB7fSAvLyBib3VuZCB0byBzZWxmXG5cbiAgICBjb25zdCBmdW5jdGlvbk5hbWVzID0gUmVmbGVjdC5vd25LZXlzIChmdW5jdGlvbnNfKSAvLyBndWFyYW50ZWVkIHRvIGJlIGluIHByb3BlcnR5IGNyZWF0aW9uIG9yZGVyIChhcyBkZWZpbmVkIGJ5IHRoZSBzdGFuZGFyZClcbiAgICBjb25zdCBzZWxmID0gTy5hc3NpZ24gKFxuXG4gICAgLyogIEZ1bmN0aW9uIG9mIGZ1bmN0aW9ucyAoY2FsbCBjaGFpbikgICovXG5cbiAgICAgICAgKC4uLmluaXRpYWwpID0+IGZ1bmN0aW9uTmFtZXMucmVkdWNlICgobWVtbywgaykgPT4gZnVuY3Rpb25zW2tdLmNhbGwgKHNlbGYsIG1lbW8sIHsgaW5pdGlhbEFyZ3VtZW50czogaW5pdGlhbCB9KSwgaW5pdGlhbCksXG5cbiAgICAvKiAgQWRkaXRpb25hbCBtZXRob2RzICAgICAqL1xuXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyZSAob3ZlcnJpZGVzID0ge30pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkRnVuY3Rpb25zID0ge31cblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgayBvZiBmdW5jdGlvbk5hbWVzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3ZlcnJpZGUgPSBvdmVycmlkZXNba10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZSAgID0gb3ZlcnJpZGVzWycrJyArIGtdIHx8ICh4ID0+IHgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlciAgICA9IG92ZXJyaWRlc1trICsgJysnXSB8fCAoeCA9PiB4KVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvdW5kQXJncyA9ICh0eXBlb2Ygb3ZlcnJpZGUgPT09ICdib29sZWFuJykgPyB7IHllczogb3ZlcnJpZGUgfSA6IChvdmVycmlkZSB8fCB7fSlcblxuICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEZ1bmN0aW9uc1trXSA9IGZ1bmN0aW9uICh4LCBhcmdzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZuID0gKHR5cGVvZiBvdmVycmlkZSA9PT0gJ2Z1bmN0aW9uJykgPyBvdmVycmlkZSA6IGZ1bmN0aW9uc1trXSAvLyBkb250IGNhY2hlIHNvIHBlb3BsZSBjYW4gZHluYW1pY2FsbHkgY2hhbmdlIC5pbXBsICgpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0FyZ3MgPSBPLmFzc2lnbiAoe30sIGJvdW5kQXJncywgYXJncyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXliZUZuID0gKG5ld0FyZ3MueWVzID09PSBmYWxzZSkgPyAoeCA9PiB4KSA6IGZuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZnRlci5jYWxsICh0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVGbi5jYWxsICh0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZS5jYWxsICh0aGlzLCB4LCBuZXdBcmdzKSwgbmV3QXJncyksIG5ld0FyZ3MpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcGlwZXogKG1vZGlmaWVkRnVuY3Rpb25zLCBzZWxmKS5tZXRob2RzICh0aGlzLm1ldGhvZHNfKVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZnJvbSAobmFtZSkge1xuXG4gICAgICAgICAgICAgICAgbGV0IHN1YnNldCA9IG51bGxcblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgayBvZiBmdW5jdGlvbk5hbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrID09PSBuYW1lKSB7IHN1YnNldCA9IHsgdGFrZUZpcnN0QXJndW1lbnQ6IChhcmdzLCBjZmcpID0+IGFyZ3NbMF0gfSB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJzZXQpIHsgc3Vic2V0W2tdID0gZnVuY3Rpb25zW2tdIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcGlwZXogKHN1YnNldCwgc2VsZilcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGJlZm9yZSAobmFtZSkge1xuXG4gICAgICAgICAgICAgICAgbGV0IHN1YnNldCA9IHt9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGsgb2YgZnVuY3Rpb25OYW1lcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoayA9PT0gbmFtZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNldFtrXSA9IGZ1bmN0aW9uc1trXVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBwaXBleiAoc3Vic2V0LCBzZWxmKVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgbWV0aG9kc186IHt9LFxuXG4gICAgICAgICAgICBtZXRob2RzIChtZXRob2RzKSB7IHJldHVybiBtZXJnZSAodGhpcywgbWVyZ2UgKHRoaXMubWV0aG9kc18sIG1ldGhvZHMpKSB9LFxuXG4gICAgICAgICAgICBnZXQgaW1wbCAoKSB7IHJldHVybiBmdW5jdGlvbnMgfSxcbiAgICAgICAgICAgIGdldCBwcmV2ICgpIHsgcmV0dXJuIHByZXYgfVxuICAgICAgICB9XG4gICAgKVxuXG4gICAgZm9yIChsZXQgW2ssIGZdIG9mIE8uZW50cmllcyAoZnVuY3Rpb25zXykpIHsgZnVuY3Rpb25zW2tdID0gZi5iaW5kIChzZWxmKSB9XG5cbiAgICByZXR1cm4gc2VsZlxufVxuXG4vKiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4iXX0=